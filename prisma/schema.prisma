// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Enums para padronizar valores
enum Rarity {
  COMUM
  RARO
  EPICO // Renomeado de CHATYNIRARES para clareza
  LENDARIO
  MITICO
  SUPREME // Raridade especial para o admin
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  CLOSED
}

enum AppealStatus {
  PENDING
  APPROVED
  REJECTED
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum GiftType {
  COINS
  CHARACTER
}

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url = env("DATABASE_URL")
}

// Modelo para os usuários verificados
model User {
  id           String    @id @default(cuid())
  email        String    @unique
  username     String    @unique
  passwordHash String
  coins        Int       @default(0)
  health       Int       @default(100)
  level        Int       @default(1)
  xp           Int       @default(0)
  xpToNextLevel Int      @default(100)
  statPoints   Int       @default(0)
  strength     Int       @default(1)
  vitality     Int       @default(1)
  isAdmin      Boolean   @default(false)
  isBanned     Boolean   @default(false)
  banReason    String?
  profilePictureUrl String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  characters   Character[]
  tickets      Ticket[]
  swords       Sword[]
  appeal       BanAppeal?
  claimedGiftLinks GiftLink[]
  sentFriendRequests     Friendship[]     @relation("sentFriendRequests")
  receivedFriendRequests Friendship[]     @relation("receivedFriendRequests")
  sentMessages           PrivateMessage[] @relation("sentMessages")
  receivedMessages       PrivateMessage[] @relation("receivedMessages")
}

// Modelo para os personagens que um usuário possui
model Character {
  id String @id @default(cuid())
  name String
  ability String
  rarity          Rarity  @default(COMUM)
  rarityColor     String?
  buffDescription String?
  attack          Int     @default(10)
  health          Int     @default(100)
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId String
}

// Modelo para as espadas que um usuário possui
model Sword {
  id          String  @id @default(cuid())
  name        String
  description String
  attackBonus Int
  rarity      Rarity  @default(COMUM)
  imageUrl    String?
  owner       User    @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId     String
}

// Modelo para os tickets de suporte
model Ticket {
  id        Int      @id @default(autoincrement())
  subject   String
  message   String
  status    TicketStatus @default(OPEN)
  createdAt DateTime @default(now())
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  messages  TicketMessage[]
}

// Modelo para usuários pendentes de verificação
model PendingUser {
  id               String   @id @default(cuid())
  email            String   @unique
  username         String
  passwordHash     String
  verificationCode String
  createdAt        DateTime @default(now())
}

// Modelo para tokens de redefinição de senha
model PasswordReset {
  id        String   @id @default(cuid())
  token     String   @unique
  email     String
  expires   DateTime
  createdAt DateTime @default(now())
}

// Modelo para o log de ações do administrador
model AdminLog {
  id        Int      @id @default(autoincrement())
  action    String // Ex: "BAN_USER", "GIVE_COINS"
  details   String // Ex: "Baniu o usuário test@example.com por spam."
  adminName String
  createdAt DateTime @default(now())
}

// Modelo para as mensagens dentro de um ticket
model TicketMessage {
  id        Int      @id @default(autoincrement())
  content   String
  isAdmin   Boolean  @default(false)
  authorName String
  createdAt DateTime @default(now())
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  ticketId  Int
}

// Modelo para apelos de banimento
model BanAppeal {
  id        Int      @id @default(autoincrement())
  content   String
  status    AppealStatus @default(PENDING)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @unique // Um usuário só pode ter um apelo por vez
}

// Modelo para links de presente
model GiftLink {
  id              String    @id @default(cuid())
  token           String    @unique
  giftType        GiftType
  giftValue       String // Quantidade de moedas ou nome do personagem
  giftMeta        String?   // Informações extras, como a raridade do personagem
  expiresAt       DateTime
  createdAt       DateTime  @default(now())
  claimed         Boolean   @default(false)
  claimedByUser   User?     @relation(fields: [claimedByUserId], references: [id])
  claimedByUserId String?   // Este campo agora está corretamente vinculado ao modelo User
}

// Modelo para armazenar os status de RPG do Admin
model AdminStats {
  id Int @id @default(1) // Usamos um ID fixo para garantir que haja apenas uma linha
  attack Int @default(999)
  health Int @default(9999)
  updatedAt DateTime @updatedAt
}

model Friendship {
  id          String           @id @default(cuid())
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  requester   User             @relation("sentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  requesterId String
  receiver    User             @relation("receivedFriendRequests", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String

  @@unique([requesterId, receiverId])
}

model PrivateMessage {
  id         String   @id @default(cuid())
  content    String
  createdAt  DateTime @default(now())
  sender     User     @relation("sentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  senderId   String
  receiver   User     @relation("receivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId String
}
